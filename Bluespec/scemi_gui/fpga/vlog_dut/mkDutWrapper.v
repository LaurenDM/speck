//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Thu May  5 09:58:14 EDT 2016
//
//
// Ports:
// Name                         I/O  size props
// RDY_dut_request_put            O     1
// dut_response_get               O    48
// RDY_dut_response_get           O     1
// RDY_setkeyandIV_put            O     1
// CLK_clk_usr                    I     1 clock
// CLK                            I     1 clock
// RST_N                          I     1 reset
// dut_request_put                I    48
// setkeyandIV_put                I   144
// EN_dut_request_put             I     1
// EN_setkeyandIV_put             I     1
// EN_dut_response_get            I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkDutWrapper(CLK_clk_usr,
		    CLK,
		    RST_N,

		    dut_request_put,
		    EN_dut_request_put,
		    RDY_dut_request_put,

		    EN_dut_response_get,
		    dut_response_get,
		    RDY_dut_response_get,

		    setkeyandIV_put,
		    EN_setkeyandIV_put,
		    RDY_setkeyandIV_put);
  input  CLK_clk_usr;
  input  CLK;
  input  RST_N;

  // action method dut_request_put
  input  [47 : 0] dut_request_put;
  input  EN_dut_request_put;
  output RDY_dut_request_put;

  // actionvalue method dut_response_get
  input  EN_dut_response_get;
  output [47 : 0] dut_response_get;
  output RDY_dut_response_get;

  // action method setkeyandIV_put
  input  [143 : 0] setkeyandIV_put;
  input  EN_setkeyandIV_put;
  output RDY_setkeyandIV_put;

  // signals for module outputs
  wire [47 : 0] dut_response_get;
  wire RDY_dut_request_put, RDY_dut_response_get, RDY_setkeyandIV_put;

  // ports of submodule fromSyncQ
  wire [47 : 0] fromSyncQ$dD_OUT, fromSyncQ$sD_IN;
  wire fromSyncQ$dDEQ, fromSyncQ$dEMPTY_N, fromSyncQ$sENQ, fromSyncQ$sFULL_N;

  // ports of submodule ofb
  wire [95 : 0] ofb$setKeyIV_key;
  wire [47 : 0] ofb$getResult, ofb$inputMessage_text, ofb$setKeyIV_iv;
  wire ofb$EN_getResult,
       ofb$EN_inputMessage,
       ofb$EN_reset,
       ofb$EN_setKeyIV,
       ofb$RDY_getResult,
       ofb$RDY_inputMessage,
       ofb$RDY_setKeyIV;

  // ports of submodule rst_usr
  wire rst_usr$OUT_RST;

  // ports of submodule toKeySyncQ
  wire [143 : 0] toKeySyncQ$dD_OUT, toKeySyncQ$sD_IN;
  wire toKeySyncQ$dDEQ,
       toKeySyncQ$dEMPTY_N,
       toKeySyncQ$sENQ,
       toKeySyncQ$sFULL_N;

  // ports of submodule toSyncQ
  wire [47 : 0] toSyncQ$dD_OUT, toSyncQ$sD_IN;
  wire toSyncQ$dDEQ, toSyncQ$dEMPTY_N, toSyncQ$sENQ, toSyncQ$sFULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_enqRequest,
       CAN_FIRE_RL_getResponse,
       CAN_FIRE_RL_putKey,
       CAN_FIRE_dut_request_put,
       CAN_FIRE_dut_response_get,
       CAN_FIRE_setkeyandIV_put,
       WILL_FIRE_RL_enqRequest,
       WILL_FIRE_RL_getResponse,
       WILL_FIRE_RL_putKey,
       WILL_FIRE_dut_request_put,
       WILL_FIRE_dut_response_get,
       WILL_FIRE_setkeyandIV_put;

  // action method dut_request_put
  assign RDY_dut_request_put = toSyncQ$sFULL_N ;
  assign CAN_FIRE_dut_request_put = toSyncQ$sFULL_N ;
  assign WILL_FIRE_dut_request_put = EN_dut_request_put ;

  // actionvalue method dut_response_get
  assign dut_response_get = fromSyncQ$dD_OUT ;
  assign RDY_dut_response_get = fromSyncQ$dEMPTY_N ;
  assign CAN_FIRE_dut_response_get = fromSyncQ$dEMPTY_N ;
  assign WILL_FIRE_dut_response_get = EN_dut_response_get ;

  // action method setkeyandIV_put
  assign RDY_setkeyandIV_put = toKeySyncQ$sFULL_N ;
  assign CAN_FIRE_setkeyandIV_put = toKeySyncQ$sFULL_N ;
  assign WILL_FIRE_setkeyandIV_put = EN_setkeyandIV_put ;

  // submodule fromSyncQ
  SyncFIFO #(.dataWidth(32'd48),
	     .depth(32'd2),
	     .indxWidth(32'd1)) fromSyncQ(.sCLK(CLK_clk_usr),
					  .dCLK(CLK),
					  .sRST(rst_usr$OUT_RST),
					  .sD_IN(fromSyncQ$sD_IN),
					  .sENQ(fromSyncQ$sENQ),
					  .dDEQ(fromSyncQ$dDEQ),
					  .sFULL_N(fromSyncQ$sFULL_N),
					  .dEMPTY_N(fromSyncQ$dEMPTY_N),
					  .dD_OUT(fromSyncQ$dD_OUT));

  // submodule ofb
  mkSynthesizedOFB ofb(.CLK(CLK_clk_usr),
		       .RST_N(rst_usr$OUT_RST),
		       .inputMessage_text(ofb$inputMessage_text),
		       .setKeyIV_iv(ofb$setKeyIV_iv),
		       .setKeyIV_key(ofb$setKeyIV_key),
		       .EN_setKeyIV(ofb$EN_setKeyIV),
		       .EN_inputMessage(ofb$EN_inputMessage),
		       .EN_getResult(ofb$EN_getResult),
		       .EN_reset(ofb$EN_reset),
		       .RDY_setKeyIV(ofb$RDY_setKeyIV),
		       .RDY_inputMessage(ofb$RDY_inputMessage),
		       .getResult(ofb$getResult),
		       .RDY_getResult(ofb$RDY_getResult),
		       .RDY_reset());

  // submodule rst_usr
  SyncResetA #(.RSTDELAY(32'd5)) rst_usr(.CLK(CLK_clk_usr),
					 .IN_RST(RST_N),
					 .OUT_RST(rst_usr$OUT_RST));

  // submodule toKeySyncQ
  SyncFIFO #(.dataWidth(32'd144),
	     .depth(32'd2),
	     .indxWidth(32'd1)) toKeySyncQ(.sCLK(CLK),
					   .dCLK(CLK_clk_usr),
					   .sRST(RST_N),
					   .sD_IN(toKeySyncQ$sD_IN),
					   .sENQ(toKeySyncQ$sENQ),
					   .dDEQ(toKeySyncQ$dDEQ),
					   .sFULL_N(toKeySyncQ$sFULL_N),
					   .dEMPTY_N(toKeySyncQ$dEMPTY_N),
					   .dD_OUT(toKeySyncQ$dD_OUT));

  // submodule toSyncQ
  SyncFIFO #(.dataWidth(32'd48),
	     .depth(32'd2),
	     .indxWidth(32'd1)) toSyncQ(.sCLK(CLK),
					.dCLK(CLK_clk_usr),
					.sRST(RST_N),
					.sD_IN(toSyncQ$sD_IN),
					.sENQ(toSyncQ$sENQ),
					.dDEQ(toSyncQ$dDEQ),
					.sFULL_N(toSyncQ$sFULL_N),
					.dEMPTY_N(toSyncQ$dEMPTY_N),
					.dD_OUT(toSyncQ$dD_OUT));

  // rule RL_enqRequest
  assign CAN_FIRE_RL_enqRequest = toSyncQ$dEMPTY_N && ofb$RDY_inputMessage ;
  assign WILL_FIRE_RL_enqRequest = CAN_FIRE_RL_enqRequest ;

  // rule RL_getResponse
  assign CAN_FIRE_RL_getResponse = fromSyncQ$sFULL_N && ofb$RDY_getResult ;
  assign WILL_FIRE_RL_getResponse = CAN_FIRE_RL_getResponse ;

  // rule RL_putKey
  assign CAN_FIRE_RL_putKey = toKeySyncQ$dEMPTY_N && ofb$RDY_setKeyIV ;
  assign WILL_FIRE_RL_putKey = CAN_FIRE_RL_putKey ;

  // submodule fromSyncQ
  assign fromSyncQ$sD_IN = ofb$getResult ;
  assign fromSyncQ$sENQ = CAN_FIRE_RL_getResponse ;
  assign fromSyncQ$dDEQ = EN_dut_response_get ;

  // submodule ofb
  assign ofb$inputMessage_text = toSyncQ$dD_OUT ;
  assign ofb$setKeyIV_iv = toKeySyncQ$dD_OUT[47:0] ;
  assign ofb$setKeyIV_key = toKeySyncQ$dD_OUT[143:48] ;
  assign ofb$EN_setKeyIV = CAN_FIRE_RL_putKey ;
  assign ofb$EN_inputMessage = CAN_FIRE_RL_enqRequest ;
  assign ofb$EN_getResult = CAN_FIRE_RL_getResponse ;
  assign ofb$EN_reset = 1'b0 ;

  // submodule toKeySyncQ
  assign toKeySyncQ$sD_IN = setkeyandIV_put ;
  assign toKeySyncQ$sENQ = EN_setkeyandIV_put ;
  assign toKeySyncQ$dDEQ = CAN_FIRE_RL_putKey ;

  // submodule toSyncQ
  assign toSyncQ$sD_IN = dut_request_put ;
  assign toSyncQ$sENQ = EN_dut_request_put ;
  assign toSyncQ$dDEQ = CAN_FIRE_RL_enqRequest ;
endmodule  // mkDutWrapper

